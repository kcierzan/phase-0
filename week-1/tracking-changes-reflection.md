# How does tracking and adding changes make developers' lives easier?

Tracking and adding changes allows for developers to determine which files are being tracked for their changes by git, which files have yet to be added, and which changed files are ready to be committed. This allows developers to monitor their local changes to files and directories and easily compartmentalize them based on their status. The system of adding, tracking, and committing allows for developers to easily manage what changes are pushed to a branch what still needs work.

# What is a commit?

A commit is a kind of "checkpoint" or "save" where changes that have been made are placed in a sort of snapshot that can then be pushed to a branch. One can navigate between commits in the event that a recent commit breaks a feature or throws errors etc. A commit is a way to manage intended contributions to a branch.

# What are the best practices for commit messages?

Commit messages are best written in the imperative, present tense. This is in keeping with the messages generated by git. Also, it creates a sense in the reader of what applying the commit will accomplish. It allows one to easily asses the intended effect of the commit if applied rather than a description of something that had already been completed. The first line should be a short description, ideally of less than 50 characters, while the body should be descriptive of the intended behavior and motivation for implementing that behavior.

# What does the HEAD^ argument mean?

The "HEAD^" argument refers to the last commit. This is useful because it allows one to take a step back to the previous commit and undo changes made in the latest commit.

# What are the 3 stages of a git change and how do you move a file from one stage to another?

The first stage of a git change is "untracked". These are often newly created files or directories that are not yet being "seen" by git. Git is not tracking any modifications to these files. In order for these files to move to the second phase "tracked/staged for commit", they must be "added" using "git add". Once that is accomplished, git will monitor any changes made to the files. Once the files/directories are ready to be commited, the command "git commit -m" will commit the changes with space for a commit message. A commit is the final stage of a git change.

# Write a handy cheatsheet of the commands you need to commit your changes

**git log**: displays log of recent commits

** git status**: displays the status of the current branch with untracked, not staged (tracked), and to be commited files/directories.

**git add**: adds an untracked file to "changes not staged for commit".

**git commit -m**: commits a file with a commit message

**git reset --soft HEAD^**: make changes to committed files by resetting head to the previous commit.

# What is a pull request and how do you create and merge one?

A pull request is a way to merge one branch into another branch or into the master branch. A pull request takes place after a branch with changes is pushed to another branch on GitHub. On GitHub, the branch in question will display a "compare & pull request" button where one can compare the code being added with the master file. Comments regarding the pull request can be added and the code can be reviewed before the merge is completed.

# Why are pull requests preferred when working with teams?

Pull requests are preferred when working with teams because it allows teams to work in a nonlinear way and to review and incorporate one another's code as necessary while mitigating the risk of potentially disastrous overwrites or feature-breaking bugs as a result of a merge. Pull requests allow groups to review code before it is merged which allows teams to address potential issues en masse.

